Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id 33CA28D822
	for <lists+linux-kernel@lfdr.de>; Wed, 14 Aug 2019 18:33:07 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1728334AbfHNQdE (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Wed, 14 Aug 2019 12:33:04 -0400
Received: from mx2.suse.de ([195.135.220.15]:47332 "EHLO mx1.suse.de"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1726166AbfHNQdE (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Wed, 14 Aug 2019 12:33:04 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.220.254])
        by mx1.suse.de (Postfix) with ESMTP id F1463B061;
        Wed, 14 Aug 2019 16:33:01 +0000 (UTC)
Date:   Wed, 14 Aug 2019 18:33:01 +0200
Message-ID: <s5hmugbbtc2.wl-tiwai@suse.de>
From:   Takashi Iwai <tiwai@suse.de>
To:     =?UTF-8?B?5b2t6L6J?= <benquike@gmail.com>
Cc:     security@kernel.org, alsa-devel@alsa-project.org,
        YueHaibing <yuehaibing@huawei.com>,
        Thomas Gleixner <tglx@linutronix.de>,
        Allison Randal <allison@lohutok.net>,
        Mathias Payer <mathias.payer@nebelwelt.net>,
        Jaroslav Kysela <perex@perex.cz>,
        Takashi Iwai <tiwai@suse.com>, Wenwen Wang <wang6495@umn.edu>,
        linux-kernel@vger.kernel.org
Subject: Re: [PATCH] Fix an OOB bug in parse_audio_mixer_unit
In-Reply-To: <CAKpmkkUv=arsdJiexaM-UVhXEwfGN=zreny9P_kDNhQUij8=FQ@mail.gmail.com>
References: <20190814023625.21683-1-benquike@gmail.com>
        <s5hzhkcb6dh.wl-tiwai@suse.de>
        <CAKpmkkUv=arsdJiexaM-UVhXEwfGN=zreny9P_kDNhQUij8=FQ@mail.gmail.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Wed, 14 Aug 2019 18:28:39 +0200,
彭辉 wrote:
> 
> Hi, Takashi:
> Here the problem is that `desc->bLength` is controlled by the device side,
> so  `desc->bLength` may not represent the real length of the descriptor.
> That is why I use pointer arithmetic operations to derive the real size of the
> buffer
> in my patch.

But bLength is checked before calling this, i.e. it's already assured
that bLength fits within the buffer limit.  So, the result calls don't
have to care about the buffer limit itself, and they can just
concentrate on overflow over bLength.


thanks,

Takashi

> 
> On Wed, Aug 14, 2019 at 2:36 AM Takashi Iwai <tiwai@suse.de> wrote:
> 
>     On Wed, 14 Aug 2019 04:36:24 +0200,
>     Hui Peng wrote:
>     >
>     > The `uac_mixer_unit_descriptor` shown as below is read from the
>     > device side. In `parse_audio_mixer_unit`, `baSourceID` field is
>     > accessed from index 0 to `bNrInPins` - 1, the current implementation
>     > assumes that descriptor is always valid (the length  of descriptor
>     > is no shorter than 5 + `bNrInPins`). If a descriptor read from
>     > the device side is invalid, it may trigger out-of-bound memory
>     > access.
>     >
>     > ```
>     > struct uac_mixer_unit_descriptor {
>     >       __u8 bLength;
>     >       __u8 bDescriptorType;
>     >       __u8 bDescriptorSubtype;
>     >       __u8 bUnitID;
>     >       __u8 bNrInPins;
>     >       __u8 baSourceID[];
>     > }
>     > ```
>     >
>     > This patch fixes the bug by add a sanity check on the length of
>     > the descriptor.
>     >
>     > Signed-off-by: Hui Peng <benquike@gmail.com>
>     > Reported-by: Hui Peng <benquike@gmail.com>
>     > Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
>     > ---
>     >  sound/usb/mixer.c | 9 +++++++++
>     >  1 file changed, 9 insertions(+)
>     >
>     > diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
>     > index 7498b5191b68..38202ce67237 100644
>     > --- a/sound/usb/mixer.c
>     > +++ b/sound/usb/mixer.c
>     > @@ -2091,6 +2091,15 @@ static int parse_audio_mixer_unit(struct
>     mixer_build *state, int unitid,
>     >       struct usb_audio_term iterm;
>     >       int input_pins, num_ins, num_outs;
>     >       int pin, ich, err;
>     > +     int desc_len = (int) ((unsigned long) state->buffer +
>     > +                     state->buflen - (unsigned long) raw_desc);
>     > +
>     > +     if (desc_len < sizeof(*desc) + desc->bNrInPins) {
>     > +             usb_audio_err(state->chip,
>     > +                           "descriptor %d too short\n",
>     > +                           unitid);
>     > +             return -EINVAL;
>     > +     }
>     > 
>     >       err = uac_mixer_unit_get_channels(state, desc);
>     >       if (err < 0) {
>    
>     Hm, what is the desc->bLength value in the error case?
>    
>     Basically the buffer boundary is already checked against bLength in
>     snd_usb_find_desc() which is called from obtaining the raw_desc in the
>     caller of this function (parse_audio_unit()).
>    
>     So, if any, we need to check bLength for the possible overflow like
>     below.
> 
>     thanks,
>    
>     Takashi
>    
>     --- a/sound/usb/mixer.c
>     +++ b/sound/usb/mixer.c
>     @@ -744,6 +744,8 @@ static int uac_mixer_unit_get_channels(struct
>     mixer_build *state,
>                     return -EINVAL;
>             if (!desc->bNrInPins)
>                     return -EINVAL;
>     +       if (desc->bLength < sizeof(*desc) + desc->bNrInPins)
>     +               return -EINVAL;
>    
>             switch (state->mixer->protocol) {
>             case UAC_VERSION_1:
> 
> --
> May the Lord Richly Bless you and yours !
> 
> 
